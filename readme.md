# AutoRK: 4.0

![](pics/main_pic.png)

Простая библиотека для сдачи рубежного контроля

**AutoRK: 4.0** – минималистичный, но расширяемый Python‑фреймворк для пошаговых дуэлей стратегий‑ботов. Поддерживает как консольный, так и графический режимы (Pygame).

---

# Руководство по библиотеке **autork**




## 1. Установка и запуск примеров

### 1.1 Получение библиотеки

Исходный код библиотеки доступен по ссылке [на GitHub](https://github.com/TovarnovM/autork_project).

```bash
# клон репозитория (рекомендуется для разработки стратегий)
$ git clone https://github.com/TovarnovM/autork_project
```

в корне проекта лежит файл `requirements.txt`, который можно использовать для установки зависимостей:

```bash
pip install -r requirements.txt
```

### 1.2 Запуск демо‑матча в консоли

В папке 'examples' находятся примеры использования фреймворка.

---

## 2. Обзор структуры проекта

| Файл/пакет                  | Назначение                                                                                                   | Ключевые классы / функции |
| --------------------------- | ------------------------------------------------------------------------------------------------------------ | ------------------------- |
| `autork/config.py`          | Централизованные **настройки баланса** (класс `GameSettings`). Переопределяются при инициализации движка.    |                           |
| `autork/strategy.py`        | Базовый **интерфейс стратега** `Strategy` + эталонные боты `RandomStrategy`, `GreedyExpansionStrategy`.      |                           |
| `autork/engine.py`          | **Сервер матча** : класс `Engine`, управляющий экономикой, боёвкой, разведкой и логированием.                |                           |
| `autork/gui.py`             | Наследник `Engine` с Pygame‑визуализацией.                                                                   |                           |
| `autork/strategies_demo.py` | Расширенный набор готовых стратегий (rush, turtle, adaptive и т.д.) — отличная отправная точка для изучения. |                           |
| `autork/__init__.py`        | Экспортирует `__version__`.                                                                                  |                           |

---

## 3. Пишем собственную стратегию

### 3.1 Минимальный шаблон

```python
# my_strategies.py
from autork.strategy import Strategy

class MyFirstStrategy(Strategy):
    """Самый простой бот: тратит всё золото на покупку одной клетки нейтрала."""
    sname = "my_first"      # <‑‑ ОБЯЗАТЕЛЬНО уникальное строковое имя
    author = "Иван Петров"  # <‑‑ ОБЯЗАТЕЛЬНО имя/ник автора

    def reset(self, initial_observation):
        """Вызывается один раз перед стартом матча."""
        # Можно сохранить стартовое состояние, сбросить счётчики и т.п.
        self.turn = 0

    def step(self, obs):
        """Вызывается каждый ход и должна вернуть *команду*‑словарь."""
        self.turn += 1
        gold = obs["my"]["gold"]
        price = obs["prices"]["expand_next"]
        cells = gold // price  # купим максимум доступных клеток
        return {
            "expand": cells,
            "spend_attack": 0,
            "spend_defense": 0,
            "sell_attack": 0,
            "sell_defense": 0,
            "scout": False,
        }
```

**Что обязательно:**

| Атрибут   | Тип   | Значение                                                                     | Зачем |
| --------- | ----- | ---------------------------------------------------------------------------- | ----- |
| `sname`   | `str` | уникальный идентификатор стратегии (используется в турнире, логах и GUI)     | ✅     |
| `author`  | `str` | ваше имя, ник или команда                                                    | ✅     |
| `reset()` | метод | получает стартовый `observation`, обнуляет внутреннее состояние              | ✅     |
| `step()`  | метод | принимает текущий `observation`, возвращает команду‑словарь — см. табл. ниже | ✅     |

#### 3.2 Формат команды, возвращаемой `step()`

| Ключ            | Тип    | Значение по‑умолчанию | Что делает                                                                                                                         |
| --------------- | ------ | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `expand`        | `int`  | `0`                   | Купить **N** клеток нейтрала (если золота хватит).                                                                                 |
| `spend_attack`  | `int`  | `0`                   | Выделить золото на покупку атаки. Движок сделает несколько покупок подряд, пока хватит денег.                                      |
| `spend_defense` | `int`  | `0`                   | Аналогично, но для защиты.                                                                                                         |
| `sell_attack`   | `int`  | `0`                   | Добровольно продать N единиц атаки (вернётся примерно половина первоначальной цены).                                               |
| `sell_defense`  | `int`  | `0`                   | Продать N единиц защиты.                                                                                                           |
| `scout`         | `bool` | `False`               | Истратить фиксированную цену (`SCOUT_COST`) на разведку; следующий ход в `obs["enemy"]` будут открыты `gold`, `attack`, `defense`. |

Любой пропущенный ключ трактуется как «0 / False».

---

## 4. Проверяем стратегию в поединке

Создадим скрипт `run_match.py`:

```python
from autork.engine import Engine
from autork.strategy import RandomStrategy
from my_strategies import MyFirstStrategy

game = Engine(MyFirstStrategy(), RandomStrategy(), trace=print)
result = game.run()
print("Итог:", result)
```

Запустите:

```bash
python run_match.py
```

Вы увидите в консоли подробный лог хода игры: доход, траты, распределение нейтрала, урон и т.д. Поле `result` содержит финального победителя и статистику (территория, золото, сила).

### 4.1 Сравнение с несколькими встроенными ботами

```python
from autork.engine import Engine
from autork.strategies_demo import UltraAggressiveStrategy, UltraDefensiveStrategy
from my_strategies import MyFirstStrategy

pairs = [
    (MyFirstStrategy(), UltraAggressiveStrategy()),
    (MyFirstStrategy(), UltraDefensiveStrategy()),
]
for a, b in pairs:
    res = Engine(a, b, trace=lambda *_: None).run()  # тихий режим
    print(f"{a.sname} vs {b.sname}: winner →", res["winner"], "за", res["turns"], "ходов")
```



## 5. Подробное описание игровой логики

### 5.1 Что происходит во время сражения

Во время игры движок последовательно вызывает метод `step()` у каждого бота, передавая ему текущую ситуацию (Observation). После этого движок обрабатывает команды, присланные ботами, обновляет экономику и вычисляет итоги боя.

### 5.2 Формат Observation

На каждом ходу метод `step()` получает объект Observation — это словарь, содержащий:

* `my` (словарь): текущие параметры вашего бота:

  * `gold`: количество доступного золота.
  * `territory`: количество контролируемых территорий.
  * `attack`: текущий уровень атаки.
  * `defense`: текущий уровень защиты.

* `enemy` (словарь): доступные данные о противнике (может быть скрытым до разведки):

  * `gold`: золото противника.
  * `attack`: атака противника.
  * `defense`: защита противника.

* `prices` (словарь): текущие цены на действия:

  * `expand_next`: стоимость приобретения следующей территории.
  * `attack_next`: стоимость приобретения следующей единицы атаки.
  * `defense_next`: стоимость приобретения следующей единицы защиты.

* `neutral`: количество нейтральных территорий, доступных для захвата.

### 5.3 Возможные действия игрока

Игрок может каждый ход осуществлять следующие действия:

* **Приобретение территорий** (`expand`): каждая новая территория увеличивает доход золота.
* **Приобретение атаки** (`spend_attack`): увеличивает боевую мощь, но требует затрат на содержание.
* **Приобретение защиты** (`spend_defense`): снижает урон, получаемый от атак противника.
* **Продажа атаки** (`sell_attack`): позволяет вернуть часть потраченных средств.
* **Продажа защиты** (`sell_defense`): аналогично продаже атаки.
* **Разведка** (`scout`): временно раскрывает скрытые параметры противника (золото, атака, защита).

### 5.4 Логика взаимодействия

На каждом ходу движок выполняет команды в следующем порядке:

1. Сначала проводятся операции покупки или продажи атак и защит.
2. Далее захватываются территории, если на это хватает золота.
3. Затем проводится разведка (если была заказана).
4. В конце хода движок подсчитывает результаты столкновения армий и обновляет золото и территории в зависимости от результата сражения.

Таким образом, ваша стратегия должна учитывать баланс между расширением территорий и инвестированием в военные возможности, а также необходимость разведки для принятия решений.

---

## 6. Дополнительные ресурсы и отладка

Используйте GUI-режим для визуализации матчей, а также логи (`trace`) для глубокого анализа работы вашей стратегии.

---
